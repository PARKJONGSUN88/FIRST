테이블 컬럼 추가 :  alter table ~ add (컬럼 컬럼타입 [제약조건]);
테이블 컬럼 삭제 :  alter table ~ drop column 컬럼명;
                    alter table ~ drop (컬럼, 컬럼);
테이블 컬럼 이름 변경  : alter table ~ rename column  old to new;
테이블 컬럼타입 또는 size 변경 : alter table ~ modify (컬럼 컬럼타입(size));

제약조건을 컬럼추가 : alter table ~ add constraint 이름 타입 ;
컬럼에 정의되어 있는 제약조건 삭제 : alter table ~ drop constraint 이름;
제약조건을 활성화 : alter table ~ enable constraint 이름;
제약조건을 비활성화 : alter table ~ disable constraint 이름;

테이블 삭제 :  drop table ~ ;  또는 drop table ~ purge;
recyclebin으로부터 drop된 테이블 복원 : flashback table ~ to before drop;
테이블의 구조는 남겨두고 데이터만 물리적으로 완전시키고, 사용했던 공간 할당 해제하지 않기 위해 사용하는 명령어 :  truncate table ~;  / truncate table ~ reuse storage;

View : 논리적 테이블, table에 대한 window
Simple View - DML이 가능한 뷰 (base table의 not null 컬럼 모두 포함, 표현식 X, 그룹핑 X, rowid X, rownum X)
Complex View -  DML이 불가능한 뷰 (2개 이상의 테이블로부터 join 포함, 그룹핑, 함수 표현식 등이 포함된 경우)
View 사용 목적 - 보안, 간결한 sql 사용

create [or replace ] [force|noforce] view 뷰이름 
as 
  select ~
  from ~
  [where ~]
  [group by ~]
  [having ~]
  [order by ~]
  [with check option]  ---체크 제약 조건
  [with read only]  --read only 제약조건

user_views, all_views, dba_views - text컬럼
alter view 구문 X
drop view 뷰이름 ---테이블에 영향을 주지 않습니다.

테이블 삭제하면 - 구조, 데이터, 제약조건, 인덱스 함께 삭제됩니다.
테이블에 대한 view가 존재하는데..테이블이 삭제(drop)되면 뷰는 status는 invalid상태로 변경되어 사용 불가

index - 검색속도를 향상(select 수행 성능향상)을 위해서 사용하는 객체
b*tree index  -- root node - branch node - leaf node (컬럼값rowid형태로 인덱스 엔트리들이 저장됨, 컬럼값의 오름차순)
bitmap index  
단일 컬럼 인덱스
복합 컬럼 인덱스
function based index - 컬럼표현식의 결과값으로 인덱스 생성

create index ~ on 테이블(컬럼 [desc]);
alter index ~ on 테이블(컬럼....);
drop index ~ ;


Sequence -최소값~최대값 범위내에서 설정된 증감값에 따라 정수를 생성 객체
create sequence ~
[start with ~]
[increment by ~]
[minvalue ~ | nominvalue]
[maxvalue ~ | nomaxvalue]
[cache n | nocache]
[cycle | nocycle];

alter sequence ~ ;로 변경 못하는 속성은 start with
drop sequence ~;


synonym - 'schema.객체@dblink명' 처럼 긴 객체이름을 간결하게 줄여서 쓰려면 
create synonym ~ for schema.객체@dblink명;

데이터베이스에 connect하려면
대상 데이터베이스에 user명이 등록되어 있어야 하며, 인증방식도 정의되어 있어야 합니다.
create session권한이 있어야 합니다.

create user ~     --권한은 DBA(sys, system , drop user~로 삭제없음)
identified by 비밀번호
[default tablespace ~]
[temp tablespace ~]
[tablespace quota XXM]
[profile ~]
[consumer group ~]


권한 -  시스템권한 --DBA
        객체권한  ---객체의 소유자, DBA

grant 권한,.... to user명,..., role명,...public;
role? --특정 업무, 직무와 연관된 권한들을 그룹핑한 것

revoke 권한,...from user명,..., role명,...public;

객체 권한 부여 :
grant 권한,...on 객체[(컬럼,...)] to user명,..., role명,...public;
revoke 권한,...on 객체[(컬럼,...)] from user명,..., role명,...public;

role 생성 권한  --DBA
1. create role ~ ;
2. grant 권한,.... to 롤명;
3. grant 롤,..to user명,..., role명,...public;


#############JDBC 프로그래밍 단계 ########################
0. 연결할 데이터베이스의 driver class 클래스 (~.jar)를 
   - 운영체제의 환경변수 classpath에 추가
   - JDK또는 JRE의 라이브러리 검색 위치중에 외부 확장 라이브러리 저장위치 (%JAVA_HOME%jre/lib/ext)
   - 이클립스(IDE)에서 프로젝트의 bulid path>configure build path>library> add external jar......추가
1. import java.sql.*;   ---JDBC API import합니다.
2. DriverClass 로딩
   try{
      Class.forName(" ");  //oracle.jdbc.OracleDriver
   }catch(ClassNotFoundException e){
     
   }
3. Connection 객체 생성
   로딩된 드라이버 클래스의 static 멤버 객체의 DriverManager.getConnection( dburl, user , pwd ) 이용해서
   DB에 connect합니다.
   DB에 세션 생성되고, 세션이 리턴됩니다. => java.sql.Connection객체로 받습니다.
   Connection 인터페이스에 주요 메소드 : close(), createStatement(), prepareStatement(), callableStatement(), setAutoCommit(false), commit(), rollback(), setSavepoint(),..
4. SQL 실행 대행 객체 Statement 객체 생성
   Statement - 완전한 sql문장을 문자열로 전송하므로 매번 hard parsing을 수행합니다.
   PreparedStatement - sql문장중에서 변경되는 부분들을 ? (index 파라미터)로 설정해서 미리 sql을 전송하고, 실행할때마다 값만 전송해서 실행(soft parsing수행될 확률이 높습니다.)
   CallableStatement - DB에 저장되어 있는 procedure, function을 호출해서 결과를 받을때
5. SQL문 실행
   executeQuery() -- select문장, ResultSet 객체 리턴
   executeUpdate() -- DML문은 int(변경된 행수) 리턴 , DDL, DCL문
   execute()  - select문, DML문, boolean 리턴(true일때는 select수행, false 일때는 dml수행)
6. select 수행 결과 처리
   while(rs.next()) {
     rs.getInt(컬럼position | "컬럼명"),
     rs.getDouble(컬럼position | "컬럼명"),...
     rs.getString(컬럼position | "컬럼명"),
     rs.getDate(컬럼position | "컬럼명"),
      ...
   }
7. SQLException 예외 처리
8. 사용 자원 (Connection, Statement, ResultSet)들 반납 close() ---> 예외처리 필요함


소스코드에 db연결정보를 hard coding하는것은 보안상..문제가 되므로
보안 폴더에 properties파일에 key=value형태로 저장합니다.
Properties prop = new Properties();
prop.load(new FileInputStream("경로/이름.."));
String value = prop.getProperty("key");




package lab.java.core;

import java.io.FileInputStream;
import java.io.IOException;
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.Properties;

public class TransactionTest {

	public static void main(String[] args) {
		Connection con = null; //DB 연결상태 세션 정보 저장
		PreparedStatement stat = null;			
		String sql ="  ";
		try {
			Properties prop = new Properties();
			prop.load(new FileInputStream("c:/workspace/day13/src/dbinfo.properties"));
			
			Class.forName(prop.getProperty("driver"));
			System.out.println("driver loading 성공");
			con = DriverManager.getConnection(prop.getProperty("url"),
					prop.getProperty("user"),
					prop.getProperty("pwd"));
			System.out.println("db connect 성공");
			
			 
			
		}catch(ClassNotFoundException e) {
			System.out.println("driver없음");
		}catch(SQLException e) {
			System.out.println(e.getMessage());
			//db 연결 실패
		}catch(IOException e) {
			System.out.println(e.getMessage()); //properties파일의 경로, 존재 오류
		}finally {
			try {			 
				if(stat!=null)stat.close();
				if (con!=null) con.close();
			}catch(Exception e) {
				e.printStackTrace();
			}
		}//finally end	

	}//main end

}//class end

drop table product purge;
create table product (
     id  varchar2(20),
     price  number(8)
 );

 insert into product values ('사과', 500);
 insert into product values ('복숭아', 1000);
 insert into product values ('포도', 1500);
 insert into product values ('망고', 1800);
 insert into product values ('수박', 2000);
commit;




package lab.java.core;

import java.io.FileInputStream;
import java.io.IOException;
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Savepoint;
import java.sql.Statement;
import java.util.Properties;

public class TransactionTest {

	public static void main(String[] args) {
		Connection con = null; //DB 연결상태 세션 정보 저장
		PreparedStatement selectPs = null; 
		PreparedStatement updatePs = null; 
		ResultSet rs = null; 
		String query = "SELECT id, price FROM product WHERE price > ?"; 
		String update = "UPDATE product SET price = ? WHERE id = ?"; 
		try {
			Properties prop = new Properties();
			prop.load(new FileInputStream("c:/workspace/day13/src/dbinfo.properties"));
			
			Class.forName(prop.getProperty("driver"));
			System.out.println("driver loading 성공");
			con = DriverManager.getConnection(prop.getProperty("url"),
					prop.getProperty("user"),
					prop.getProperty("pwd"));
			System.out.println("db connect 성공");
			
			con.setAutoCommit(false);  //명시적 트랜잭션 제어를 위해  
			
			selectPs = con.prepareStatement(query); 
			updatePs = con.prepareStatement(update); 

			selectPs.setInt(1, 100); 
			rs = selectPs.executeQuery(); 

			Savepoint save1 = con.setSavepoint(); 
			while (rs.next()) { 
				String id = rs.getString("id"); 
				int oldPrice = rs.getInt("price"); 
				int newPrice = (oldPrice * 2); 
				updatePs.setInt(1, newPrice); 
				updatePs.setString(2, id); 
				updatePs.executeUpdate(); 
				System.out.println("New Price of " + oldPrice+ 
						" is " + newPrice); 
				if (newPrice >= 5000) {
					con.rollback(save1); 
				} 
			} //while end
			
			System.out.println(); 			
			selectPs.setInt(1, 100); 
			rs = selectPs.executeQuery(); 

			Savepoint save2 = con.setSavepoint(); 

			while (rs.next()) { 
				String id = rs.getString("id"); 
				int oldPrice = rs.getInt("price"); 
				int newPrice = (oldPrice * 2); 
				updatePs.setInt(1, newPrice); 
				updatePs.setString(2, id); 
				updatePs.executeUpdate(); 
				System.out.println("New price of  is " +newPrice); 
				if (newPrice >= 5000) { 
					con.rollback(save2); 
				} 
			} 
			System.out.println(); 
			con.commit(); 			
			
			Statement stmt = con.createStatement(); 
			rs = stmt.executeQuery("SELECT id, price FROM product"); 

			System.out.println(); 
			while (rs.next()) { 
				String id = rs.getString("id");
				int price = rs.getInt("price"); 
				System.out.println("id : "+ id 
						+" , price : " + price); 
			} 
			
		}catch(ClassNotFoundException e) {
			System.out.println("driver없음");
		}catch(SQLException e) {
			System.out.println(e.getMessage());
			//db 연결 실패
		}catch(IOException e) {
			System.out.println(e.getMessage()); //properties파일의 경로, 존재 오류
		}finally {
			try {			 
				if(rs != null)rs.close(); 
				if(selectPs != null)selectPs.close(); 
				if(updatePs != null)updatePs.close(); 
				if(con != null)con.close();
			}catch(Exception e) {
				e.printStackTrace();
			}
		}//finally end	

	}//main end

}//class end










drop table book purge;
create table Book (
isbn  varchar2(5) constraint book_isbn_pk  primary key,
category varchar(15),
title varchar2(50) ,
author varchar2(30),
price  number(6),
descript  varchar2(500)
);


insert into book (isbn, title, category, price, descript)
values ('M0001','Cooking Light', 'living, cooking', 15000, 'America Cooking');
   

insert into book (isbn, title, author, price)
values ('N0001', 'The Confession', 'Grisham, John', 10500);

commit;





















































































































